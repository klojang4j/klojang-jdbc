<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BatchQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang JDBC</a> &gt; <a href="index.source.html" class="el_package">org.klojang.jdbc</a> &gt; <span class="el_source">BatchQuery.java</span></div><h1>BatchQuery.java</h1><pre class="source lang-java linenums">package org.klojang.jdbc;

import org.klojang.check.Check;
import org.klojang.convert.NumberMethods;

import java.sql.ResultSet;
import java.time.Duration;
import java.util.List;

import static org.klojang.jdbc.x.Strings.QUERY;

/**
 * &lt;p&gt;Facilitates the processing of large query results in batches across multiple,
 * isolated requests. These would typically be HTTP requests, but any stateless
 * request-response mechanism might want to use the functionality offered by the
 * {@code BatchQuery} class. The query result will be kept alive until all records have
 * been extracted from it. Once all records have been extracted, the associated JDBC
 * resources will be closed automatically. As soon as, and as long as there are any
 * persistent query results, a background thread will periodically check whether any of
 * them have gone stale and, if so, close and remove them. Once there are no more
 * persistent query results, the thread will itself be terminated.
 *
 * &lt;p&gt;Since the point is to keep the query result alive across multiple requests, you may
 * have to suppress a (good) habit of always setting up try-with-resources blocks for
 * {@link AutoCloseable} objects (the JDBC {@link java.sql.Connection Connection} and the
 * {@link SQLQuery} in this case). This would &lt;i&gt;not&lt;/i&gt; be a good way to get hold of a
 * {@code BatchQuery}:
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * try(Connection con = ...) {
 *   SQLSession session = SQL.staticSQL(&quot;SELECT * FROM PERSON&quot;).session(con);
 *   try(SQLQuery query = session.prepareQuery()) {
 *     QueryId queryId = BatchQuery.pin(query);
 *     BatchQuery&lt;Person&gt; batchQuery = new BatchQuery&lt;&gt;(queryId, Person.class);
 *   }
 * }
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;Instead, simply write:
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * @SuppressWarnings(&quot;resource&quot;)
 * Connection con = ...;
 * SQLSession session = SQL.staticSQL(&quot;SELECT * FROM PERSON&quot;).session(con);
 * @SuppressWarnings(&quot;resource&quot;)
 * SQLQuery query = session.prepareQuery();
 * QueryId queryId = BatchQuery.pin(query);
 * BatchQuery&lt;Person&gt; batchQuery = new BatchQuery&lt;&gt;(queryId, Person.class);
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @param &lt;T&gt; the type of the JavaBeans or records produced by the
 *       {@code BatchQuery}
 */
public final class BatchQuery&lt;T&gt; {

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchQuery}
   * object, allowing it the identify and wrap itself around the query result. Equivalent
   * to {@link #pin(SQLQuery, Duration) pin(query, Duration.ofMinutes(5), true)}. In other
   * words, the client gets five minutes to process a batch before it must request the
   * {@linkplain #nextBatch(int) next batch}. After that, the query will be deemed stale
   * and the associated JDBC resources will be closed. Subsequent calls to
   * {@code nextBatch()} will cause a {@link DatabaseException}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @return a {@code QueryId}
   */
  public static QueryId pin(SQLQuery query) {
<span class="nc" id="L70">    return pin(query, Duration.ofMinutes(5), true);</span>
  }

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchQuery}
   * object, allowing it the identify and wrap itself around the query result. Equivalent
   * to {@link #pin(SQLQuery, Duration, boolean) pin(query, stayAliveTime, true)}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @param stayAliveTime determines how long the query should be kept alive between
   *       requests for new batches. If the time interval between any two consecutive
   *       requests is longer than the specified duration, the query will be deemed stale
   *       and the associated JDBC resources will be closed
   * @return a {@code QueryId}
   */
  public static QueryId pin(SQLQuery query, Duration stayAliveTime) {
<span class="nc" id="L87">    return pin(query, stayAliveTime, true);</span>
  }

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchQuery}
   * object, allowing it the identify and wrap itself around a {@link ResultSet}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @param stayAliveTime determines how long the query should be kept alive between
   *       requests for new batches. If the time interval between any two consecutive
   *       requests is longer than the specified duration, the query will be deemed stale
   *       and the associated JDBC resources will be closed
   * @param closeConnection whether to close the JDBC connection once all records
   *       have been retrieved from the underlying {@link ResultSet} (which will anyhow be
   *       closed)
   * @return a {@code QueryId}
   */
  public static QueryId pin(SQLQuery query,
        Duration stayAliveTime,
        boolean closeConnection) {
<span class="nc" id="L108">    Check.notNull(query, QUERY);</span>
<span class="nc" id="L109">    Check.notNull(stayAliveTime, &quot;stayAliveTime&quot;);</span>
<span class="nc" id="L110">    QueryCache cache = QueryCache.getInstance();</span>
<span class="nc" id="L111">    return cache.addQuery(query, stayAliveTime.getSeconds(), closeConnection);</span>
  }

  /**
   * Terminates and unpins all {@link SQLQuery} objects. All {@code BatchQuery} objects
   * instantiated before calling this method will effectively become unusable. Calls to
   * {@link #nextBatch(int) nextBatch()} will cause a {@link DatabaseException}.
   */
  public static void terminateAll() {
<span class="nc" id="L120">    QueryCache.getInstance().terminateAll();</span>
<span class="nc" id="L121">  }</span>


  private final QueryId queryId;
  private final ExtractorFactory&lt;T&gt; factory;

  /**
   * Instantiates a new {@code BatchQuery} object.
   *
   * @param queryId the ID of the query result to be processed by the
   *       {@code BatchQuery} object
   * @param factory a factory for the {@link BeanExtractor} that will process the
   *       {@code ResultSet}
   */
<span class="nc" id="L135">  public BatchQuery(QueryId queryId, ExtractorFactory&lt;T&gt; factory) {</span>
<span class="nc" id="L136">    this.queryId = queryId;</span>
<span class="nc" id="L137">    this.factory = factory;</span>
<span class="nc" id="L138">  }</span>

  /**
   * Instantiates a new {@code BatchQuery} object.
   *
   * @param queryId the ID of the query result to be processed by the
   *       {@code BatchQuery}
   * @param clazz the type of the JavaBeans or records produced by the
   *       {@code BatchQuery}
   */
<span class="nc" id="L148">  public BatchQuery(QueryId queryId, Class&lt;T&gt; clazz) {</span>
<span class="nc" id="L149">    this.queryId = queryId;</span>
<span class="nc" id="L150">    SQLQuery query = QueryCache.getInstance().getSQLQuery(queryId);</span>
<span class="nc" id="L151">    factory = query.session.getSQL().getBeanExtractorFactory(clazz);</span>
<span class="nc" id="L152">  }</span>

  /**
   * Instantiates a new {@code BatchQuery} object that will produce lists of
   * {@code Map&lt;String, Object&gt;} pseudo-objects. This requires that {@code &lt;T&gt;} (the type
   * argument for the {@code BatchQuery} variable) actually is
   * {@code &lt;Map&lt;String, Object&gt;&gt;}. Otherwise a {@link ClassCastException} will follow.
   *
   * @param queryId the ID of the query result to be processed by the
   *       {@code BatchQuery}
   */
  @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L164">  public BatchQuery(QueryId queryId) {</span>
<span class="nc" id="L165">    this.queryId = queryId;</span>
<span class="nc" id="L166">    SQLQuery query = QueryCache.getInstance().getSQLQuery(queryId);</span>
<span class="nc" id="L167">    factory = (ExtractorFactory&lt;T&gt;) query.session.getSQL().getMapExtractorFactory();</span>
<span class="nc" id="L168">  }</span>

  /**
   * Retrieves the next batch of records from the query result and converts them into
   * instances of type {@code &lt;T&gt;}. A {@link DatabaseException} is thrown if it has taken
   * too long for this method to be called since the previous time it was called (too long
   * as defined by the {@code stayAliveTime} argument passed to the
   * {@link #pin(SQLQuery, Duration, boolean) pin()} method).
   *
   * @param batchSize the number of records to retrieve
   * @return the next batch of records, converted into instances of type {@code &lt;T&gt;}
   */
  public List&lt;T&gt; nextBatch(int batchSize) {
<span class="nc" id="L181">    ResultSet rs = QueryCache.getInstance().getResultSet(queryId);</span>
<span class="nc" id="L182">    BeanExtractor&lt;T&gt; extractor = factory.getExtractor(rs);</span>
<span class="nc" id="L183">    List&lt;T&gt; beans = extractor.extract(batchSize);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">    if (extractor.isEmpty()) {</span>
<span class="nc" id="L185">      terminate();</span>
    }
<span class="nc" id="L187">    return beans;</span>
  }

  /**
   * Terminates and unpins the {@link SQLQuery} object associated with this
   * {@code BatchQuery}. Subsequent calls to {@link #nextBatch(int) nextBatch()} will
   * cause a {@link DatabaseException}. You do not need to call this method if you process
   * the query result all the way to the last row, but you might want to call it in
   * exceptional situations where you need to abort the query. Note that even if you do
   * not call this method, the {@link SQLQuery} will be terminated and unpinned, not too
   * long after requests for new batches have stopped coming in.
   */
  public void terminate() {
<span class="nc" id="L200">    QueryCache.getInstance().terminate(queryId);</span>
<span class="nc" id="L201">  }</span>

  /**
   * Functions as an identifier for a persistent query result. A {@code QueryId} (or
   * rather it string representation) is meant to be ping-ponged back and forth between
   * client and server, for example via a URL query parameter and response header,
   * respectively. On the server side it is used to instantiate a {@code BatchQuery}
   * object, allowing it to identify and wrap itself around the query result.
   */
  public static final class QueryId {

    private final int id;

<span class="nc" id="L214">    private QueryId(int id) { this.id = id; }</span>

    /**
     * Creates a {@code QueryId} from the specified string representation
     *
     * @param id the string representation of a {@code QueryId}
     * @return a {@code QueryId} from the specified string representation
     */
    public static QueryId of(String id) {
<span class="nc" id="L223">      Check.notNull(id);</span>
<span class="nc" id="L224">      return new QueryId(NumberMethods.parseInt(id));</span>
    }

    /**
     * Returns the hash code of this {@code QueryId}.
     *
     * @return the hash code of this {@code QueryId}
     */
<span class="nc" id="L232">    public int hashCode() { return id; }</span>

    /**
     * Determines whether this {@code QueryId} equals the specified object.
     *
     * @param obj the object to compare this {@code QueryId} with
     * @return whether this {@code QueryId} equals the specified object
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L242" title="All 6 branches missed.">      return this == obj || (obj instanceof QueryId qid &amp;&amp; id == qid.id);</span>
    }

    /**
     * Returns the string representation of this {@code QueryId}.
     *
     * @return the string representation of this {@code QueryId}
     */
<span class="nc" id="L250">    public String toString() { return String.valueOf(id); }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>