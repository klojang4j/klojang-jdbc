<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BatchQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang JDBC</a> &gt; <a href="index.source.html" class="el_package">org.klojang.jdbc</a> &gt; <span class="el_source">BatchQuery.java</span></div><h1>BatchQuery.java</h1><pre class="source lang-java linenums">package org.klojang.jdbc;

import org.klojang.check.Check;
import org.klojang.convert.NumberMethods;

import java.sql.Connection;
import java.sql.ResultSet;
import java.time.Duration;
import java.util.List;

import static java.lang.System.identityHashCode;
import static org.klojang.jdbc.x.Strings.QUERY;

/**
 * Facilitates the processing of large query results in batches across multiple,
 * independent requests. These would typically be HTTP requests, but any stateless
 * request-response mechanism might want to use the functionality offered by the
 * {@code BatchInsert} class. The query result will be kept alive until all records have
 * been extracted from it. Once all records have been extracted, the associated JDBC
 * resources will be closed automatically. As soon as, and as long as there are any
 * persistent query results, a background thread will periodically check whether any of
 * them have gone stale. Stale query results will be closed and removed by this thread.
 * Once there are no more persistent query results, the thread will itself be terminated.
 *
 * @param &lt;T&gt; the type of the JavaBeans or records produced by the
 *       {@code BatchQuery}
 */
public final class BatchQuery&lt;T&gt; {

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchInsert}
   * object, allowing it the identify and wrap itself around a {@link ResultSet}.
   * Equivalent to
   * {@link #register(SQLQuery, Duration) register(query, Duration.ofMinutes(10), true)}.
   * In other words, the client gets ten minutes to process a batch before it must request
   * the {@linkplain #nextBatch(int) next batch}. After that, the {@link ResultSet} will
   * be deemed stale. It will be closed and disposed of, and any subsequent call to
   * {@code nextBatch()} cause a {@link DatabaseException}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @return a {@code QueryId}
   */
  public static QueryId register(SQLQuery query) {
<span class="nc" id="L45">    return register(query, Duration.ofMinutes(10), true);</span>
  }

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchInsert}
   * object, allowing it the identify and wrap itself around a {@link ResultSet}.
   * Equivalent to
   * {@link #register(SQLQuery, Duration) register(query, stayAliveTime, true)}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @param stayAliveTime determines how long the query result should be kept alive
   *       between requests for new batches. If the time interval between any two
   *       consecutive requests is longer than the specified duration, the query result
   *       will be deemed stale and &lt;i&gt;Klojang JDBC&lt;/i&gt; will close the associated JDBC
   *       resources and remove it.
   * @return a {@code QueryId}
   */
  public static QueryId register(SQLQuery query, Duration stayAliveTime) {
<span class="nc" id="L64">    return register(query, stayAliveTime, true);</span>
  }

  /**
   * Registers the specified {@code SQLQuery} for batch processing and returns a
   * {@code QueryId}. The {@code QueryId} can be used to instantiate a {@code BatchInsert}
   * object, allowing it the identify and wrap itself around a {@link ResultSet}.
   *
   * @param query the {@code SQLQuery} to be registered for batch processing
   * @param stayAliveTime determines how long the query result should be kept alive
   *       between requests for new batches. If the time interval between any two
   *       consecutive requests is longer than the specified duration, the query result
   *       will be deemed stale and &lt;i&gt;Klojang JDBC&lt;/i&gt; will close the associated JDBC
   *       resources and remove it.
   * @param closeConnection whether to close the JDBC connection once all records
   *       have been retrieved from the underlying {@link ResultSet}
   * @return
   */
  public static QueryId register(SQLQuery query,
        Duration stayAliveTime,
        boolean closeConnection) {
<span class="nc" id="L85">    Check.notNull(query, QUERY);</span>
<span class="nc" id="L86">    Check.notNull(stayAliveTime, &quot;stayAliveTime&quot;);</span>
<span class="nc" id="L87">    ResultSet rs = query.execute();</span>
<span class="nc" id="L88">    ResultSetCache cache = ResultSetCache.getInstance();</span>
<span class="nc" id="L89">    Connection con = query.session.con;</span>
<span class="nc" id="L90">    return cache.add(con, rs, stayAliveTime.getSeconds(), closeConnection);</span>
  }

  /**
   * Terminates the processing of all query results. Any subsequent call on any existing
   * {@code BatchQuery} instances to {@link #nextBatch(int)} will cause a
   * {@link DatabaseException}.
   */
  public static void terminateAll() {
<span class="nc" id="L99">    ResultSetCache.getInstance().clearCache();</span>
<span class="nc" id="L100">  }</span>

  private final QueryId queryId;
  private final ExtractorFactory&lt;T&gt; factory;

  /**
   * Instantiates a new {@code BatchQuery} object.
   *
   * @param queryId the ID of the query result to be processed by the
   *       {@code BatchQuery} object
   * @param factory a factory for the {@link BeanExtractor} that will process the
   *       {@code ResultSet}
   */
<span class="nc" id="L113">  public BatchQuery(QueryId queryId, ExtractorFactory&lt;T&gt; factory) {</span>
<span class="nc" id="L114">    this.queryId = queryId;</span>
<span class="nc" id="L115">    this.factory = factory;</span>
<span class="nc" id="L116">  }</span>

  /**
   * Retrieves the next batch of records from the query result and converts them into
   * instances of type {@code &lt;T&gt;}. A {@link DatabaseException} is thrown if it has taken
   * too long for this method to be called since the previous time it was called (too long
   * as defined by the {@code stayAliveTime} argument passed to the
   * {@link #register(SQLQuery, Duration, boolean) register()} method).
   *
   * @param batchSize the number of records to retrieve
   * @return the next batch of records, converted into instances of type {@code &lt;T&gt;}
   */
  public List&lt;T&gt; nextBatch(int batchSize) {
<span class="nc" id="L129">    ResultSetCache cache = ResultSetCache.getInstance();</span>
<span class="nc" id="L130">    ResultSet rs = ResultSetCache.getInstance().get(queryId);</span>
<span class="nc" id="L131">    BeanExtractor&lt;T&gt; extractor = factory.getExtractor(rs);</span>
<span class="nc" id="L132">    List&lt;T&gt; beans = extractor.extract(batchSize);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (extractor.isEmpty()) {</span>
<span class="nc" id="L134">      cache.remove(queryId);</span>
    }
<span class="nc" id="L136">    return beans;</span>
  }

  /**
   * Terminates the processing of the query result. All subsequent calls to
   * {@link #nextBatch(int)} will cause a {@link DatabaseException}. Will close the
   * underlying {@link ResultSet} and possibly also the associated JDBC connection (see
   * {@link #register(SQLQuery, Duration, boolean)}). You do not need to call this method
   * if you process the query result all the way to the last row, but you might want to
   * call this in exceptional situations where you need to abort the query.
   */
  public void terminate() {
<span class="nc" id="L148">    ResultSetCache.getInstance().remove(queryId);</span>
<span class="nc" id="L149">  }</span>

  /**
   * Functions as an identifier for a persistent query result. A {@code QueryId} (or
   * rather it string representation) is meant to be ping-ponged back and forth between
   * client and server, for example via a URL query parameter and response header,
   * respectively. On the server side it is used to instantiate a {@code BatchInsert}
   * object, allowing it to identify and wrap itself around the query result.
   */
  public static final class QueryId {

    private final int id;

<span class="nc" id="L162">    private QueryId(int id) { this.id = id; }</span>

<span class="nc" id="L164">    QueryId(ResultSet rs) { this(identityHashCode(rs)); }</span>

    /**
     * Creates a {@code QueryId} from the specified string representation
     *
     * @param id the string representation of a {@code QueryId}
     * @return a {@code QueryId} from the specified string representation
     */
    public static QueryId of(String id) {
<span class="nc" id="L173">      Check.notNull(id);</span>
<span class="nc" id="L174">      return new QueryId(NumberMethods.parseInt(id));</span>
    }

    /**
     * Returns the hash code of this {@code QueryId}.
     *
     * @return the hash code of this {@code QueryId}
     */
<span class="nc" id="L182">    public int hashCode() { return id; }</span>

    /**
     * Determines whether this {@code QueryId} equals the specified object.
     *
     * @param obj the object to compare this {@code QueryId} with
     * @return whether this {@code QueryId} equals the specified object
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L192" title="All 6 branches missed.">      return this == obj || (obj instanceof QueryId qid &amp;&amp; id == qid.id);</span>
    }

    /**
     * Returns the string representation of this {@code QueryId}.
     *
     * @return the string representation of this {@code QueryId}
     */
<span class="nc" id="L200">    public String toString() { return String.valueOf(id); }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>