<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLBatchInsertBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang JDBC</a> &gt; <a href="index.source.html" class="el_package">org.klojang.jdbc</a> &gt; <span class="el_source">SQLBatchInsertBuilder.java</span></div><h1>SQLBatchInsertBuilder.java</h1><pre class="source lang-java linenums">package org.klojang.jdbc;

import org.klojang.check.Check;
import org.klojang.invoke.Getter;
import org.klojang.invoke.GetterFactory;
import org.klojang.jdbc.x.sql.BatchInsertConfig;
import org.klojang.templates.NameMapper;

import java.sql.Connection;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;

import static org.klojang.check.CommonChecks.*;
import static org.klojang.check.CommonExceptions.STATE;
import static org.klojang.check.CommonProperties.mapSize;
import static org.klojang.check.Tag.PROPERTY;
import static org.klojang.util.ObjectMethods.isEmpty;

/**
 * A builder class for {@link SQLBatchInsert} instances. {@code SQLBatchInsertBuilder}
 * instances are obtained via {@link SQL#configureBatchInsert()}.
 */
public final class SQLBatchInsertBuilder {

<span class="fc" id="L28">  private final Map&lt;String, Transformer&lt;?&gt;&gt; transformers = new HashMap&lt;&gt;();</span>

<span class="fc" id="L30">  private NameMapper nameMapper = NameMapper.AS_IS;</span>
<span class="fc" id="L31">  private int chunkSize = -1;</span>
<span class="fc" id="L32">  boolean commitPerChunk = true;</span>

  private Class&lt;?&gt; beanClass;
  private String tableName;
  private String[] properties;
  private boolean exclude;

<span class="fc" id="L39">  SQLBatchInsertBuilder() { }</span>

  /**
   * Sets the type of the beans to be saved.
   *
   * @param beanClass the type of the beans to be saved
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder of(Class&lt;?&gt; beanClass) {
<span class="fc" id="L48">    this.beanClass = Check.notNull(beanClass).ok();</span>
<span class="fc" id="L49">    return this;</span>
  }

  /**
   * Sets the table name to insert the data into. If not specified, this defaults to the
   * simple class name of the bean class.
   *
   * @param tableName the table name to insert the data into
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder into(String tableName) {
<span class="fc" id="L60">    this.tableName = Check.that(tableName).isNot(empty()).ok();</span>
<span class="fc" id="L61">    return this;</span>
  }

  /**
   * Sets the properties (and corresponding columns) to exclude from the INSERT statement.
   * You would most likely at least want to exclude the property corresponding to the
   * auto-generated key column. It makes no sense to call both this method and the
   * {@link #including(String...)} on the same {@code SQLBatchInsertBuilder} instance. The
   * last call will override the effect of any previous calls to {@code including()} and
   * {@code excluding()}.
   *
   * @param properties the properties and (corresponding columns) to exclude from the
   * INSERT statement
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder excluding(String... properties) {
<span class="fc" id="L77">    Check.that(properties).is(deepNotEmpty());</span>
<span class="fc" id="L78">    this.properties = properties;</span>
<span class="fc" id="L79">    this.exclude = true;</span>
<span class="fc" id="L80">    return this;</span>
  }

  /**
   * Sets the properties (and corresponding columns) to include in the INSERT statement.
   * It makes no sense to call both this method and the {@link #excluding(String...)} on
   * the same {@code SQLBatchInsertBuilder} instance. The last call will override the
   * effect of any previous calls to {@code including()} and {@code excluding()}.
   *
   * @param properties the properties and (corresponding columns) to include in the INSERT
   * statement
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder including(String... properties) {
<span class="nc" id="L94">    Check.that(properties).is(deepNotEmpty());</span>
<span class="nc" id="L95">    this.properties = properties;</span>
<span class="nc" id="L96">    this.exclude = false;</span>
<span class="nc" id="L97">    return this;</span>
  }

  /**
   * Sets the property-to-column mapper to be used when mapping bean properties to column
   * names. Beware of the direction of the mappings: &lt;i&gt;from&lt;/i&gt; bean properties
   * &lt;i&gt;to&lt;/i&gt; column names.
   *
   * @param propertyToColumnMapper the property-to-column mapper
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder withNameMapper(NameMapper propertyToColumnMapper) {
<span class="fc" id="L109">    Check.notNull(propertyToColumnMapper);</span>
<span class="fc" id="L110">    this.nameMapper = propertyToColumnMapper;</span>
<span class="fc" id="L111">    return this;</span>
  }

  /**
   * Sets number of beans that will be saved at a time. By default the entire batch will
   * be saved at once. Make sure this does not exceed the limits of your database or JDBC
   * client.
   *
   * @param chunkSize the number of beans that will be saved at a time
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder withChunkSize(int chunkSize) {
<span class="nc" id="L123">    Check.that(chunkSize).is(gt(), 0);</span>
<span class="nc" id="L124">    this.chunkSize = chunkSize;</span>
<span class="nc" id="L125">    return this;</span>
  }

  /**
   * Specifies whether to issue a database commit directly after een chunk of beans has
   * been saved to the database. If not, you must issue the commits yourself if and when
   * necessary. The default behaviour is to issue a commit.
   *
   * @param commitPerChunk whether to commit after een chunk of beans has been saved to
   * the database
   * @return this {@code SQLBatchInsertBuilder}
   */
  public SQLBatchInsertBuilder withCommitPerChunk(boolean commitPerChunk) {
<span class="nc" id="L138">    this.commitPerChunk = commitPerChunk;</span>
<span class="nc" id="L139">    return this;</span>
  }

  /**
   * Specifies a transformer function for the specified property. The function is passed
   * the bean to be saved and the value of the property. It must return the value to be
   * saved for that property. If the return value is anything other than {@code null}, a
   * {@link Number} or an {@link SQL#expression(String) SQL expression}, it is stringified
   * using {@code toString()} and then quoted and escaped using the database's quoting and
   * escaping rules.
   *
   * @param property the property whose value is to be transformed
   * @param transformer the transformation functions
   * @return this {@code SQLBatchInsertBuilder}
   * @see java.sql.Statement#enquoteLiteral(String)
   */
  public SQLBatchInsertBuilder withTransformer(
        String property,
        Transformer&lt;?&gt; transformer) {
<span class="nc" id="L158">    Check.notNull(property, PROPERTY);</span>
<span class="nc" id="L159">    Check.notNull(transformer, &quot;transformer&quot;);</span>
<span class="nc" id="L160">    this.transformers.put(property, transformer);</span>
<span class="nc" id="L161">    return this;</span>
  }

  /**
   * Creates and returns a {@code SQLBatchInsert} instance using the input provided via
   * the other methods
   *
   * @param con the JDBC {@code Connection} to use for the INSERT statement
   * @param &lt;T&gt; the type of the beans or records to be saved by the {@code SQLBatchInsert}
   * instance
   * @return a {@code SQLBatchInsert} instance
   */
  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
  public &lt;T&gt; SQLBatchInsert&lt;T&gt; prepare(Connection con) {
<span class="fc" id="L175">    Check.notNull(con);</span>
<span class="fc" id="L176">    Check.on(STATE, beanClass, &quot;beanClass&quot;).is(notNull());</span>
<span class="fc" id="L177">    Map&lt;String, Getter&gt; getters = GetterFactory.INSTANCE.getGetters(beanClass, true);</span>
    Getter[] getterArray;
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">    if (isEmpty(properties)) {</span>
<span class="nc" id="L180">      getterArray = getters.values().toArray(Getter[]::new);</span>
    } else {
<span class="fc bfc" id="L182" title="All 2 branches covered.">      for (String prop : properties) {</span>
<span class="fc" id="L183">        Check.that(prop).is(keyIn(), getters, noSuchProperty(prop));</span>
      }
<span class="fc" id="L185">      Map&lt;String, Getter&gt; tmp = HashMap.newHashMap(getters.size());</span>
<span class="fc" id="L186">      tmp.putAll(getters);</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">      if (exclude) {</span>
<span class="fc" id="L188">        tmp.keySet().removeAll(Set.of(properties));</span>
      } else {
<span class="nc" id="L190">        tmp.keySet().retainAll(Set.of(properties));</span>
      }
<span class="fc" id="L192">      Check.that(tmp).has(mapSize(), gt(), 0,</span>
<span class="nc" id="L193">            () -&gt; new KlojangSQLException(&quot;no properties/columns selected&quot;));</span>
<span class="fc" id="L194">      getterArray = tmp.values().toArray(Getter[]::new);</span>
    }
<span class="fc" id="L196">    Transformer[] transformerArray = Arrays.stream(getterArray)</span>
<span class="fc" id="L197">          .map(Getter::getProperty)</span>
<span class="fc" id="L198">          .map(transformers::get)</span>
<span class="fc" id="L199">          .toArray(Transformer[]::new);</span>
<span class="fc" id="L200">    BatchInsertConfig&lt;T&gt; cfg = (BatchInsertConfig&lt;T&gt;) new BatchInsertConfig&lt;&gt;(</span>
          con,
          beanClass,
          tableName,
          chunkSize,
          commitPerChunk,
          getterArray,
          transformerArray,
          nameMapper);
<span class="fc" id="L209">    return new SQLBatchInsert&lt;&gt;(cfg);</span>
  }

  private Supplier&lt;KlojangSQLException&gt; noSuchProperty(String prop) {
<span class="fc" id="L213">    String fmt = &quot;no such property in class %s: %s&quot;;</span>
<span class="fc" id="L214">    String msg = String.format(fmt, beanClass.getSimpleName(), prop);</span>
<span class="pc" id="L215">    return () -&gt; new KlojangSQLException(msg);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>