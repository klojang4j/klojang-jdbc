<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang JDBC</a> &gt; <a href="index.source.html" class="el_package">org.klojang.jdbc</a> &gt; <span class="el_source">SQLSession.java</span></div><h1>SQLSession.java</h1><pre class="source lang-java linenums">package org.klojang.jdbc;

import org.klojang.invoke.BeanReader;

import java.util.Collection;
import java.util.List;

/**
 * &lt;p&gt;An {@code SQLSession} allows you to provide values for the &lt;a
 * href=&quot;https://klojang4j.github.io/klojang-templates/api/org.klojang.templates/module-summary.html&quot;&gt;template
 * variables&lt;/a&gt; within the SQL. Once you have set all template variables, you can obtain
 * a {@link SQLStatement} object from the {@code SQLSession} and use it to set (a.k.a.
 * &quot;bind&quot;) the &lt;i&gt;named parameters&lt;/i&gt; within the SQL. The difference between template
 * variables and named parameters is explained in the comments for the {@link SQL}
 * interface. Since the {@code SQLSession} implementation obtained via
 * {@link SQL#simple(String) SQL.simple()}) does not allow for template variables, you
 * have no choice but to retrieve a {@code SQLStatement} from it straight away. If the SQL
 * does not contain any named parameters, you may call {@link #execute()} on the
 * {@code SQLSession} straight away, without going through the creation of an
 * {@code SQLStatement}.
 *
 * &lt;h2&gt;AutoCloseable&lt;/h2&gt;
 * The {@code SQLSession} interface extends {@link AutoCloseable}, so in principle you
 * should set up a try-with-resources block for {@code SQLSession} instances. However, the
 * {@code SQLSession} implementation obtained via {@link SQL#simple(String) SQL.simple()}
 * does manage any resources that need to be freed up, so in that case a
 * try-with-resources block is optional.
 */
public sealed interface SQLSession extends AutoCloseable permits AbstractSQLSession {

  /**
   * Sets the value of the specified template variable. The value will not be escaped or
   * quoted. If the value is an array or collection, it will be &quot;imploded&quot; to a string,
   * using {@code &quot;,&quot; } (comma) to separate the elements in the array or collection. This
   * method will throw an {@link UnsupportedOperationException} for
   * {@linkplain SQL#simple(String) simple SQL sessions} since these are not based on &lt;a
   * href=&quot;https://klojang4j.github.io/klojang-templates/1/api/org.klojang.templates/module-summary.html&quot;&gt;Klojang
   * Templates&lt;/a&gt;.
   *
   * @param varName the name of the template variable
   * @param value the value to set the variable to.
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   * @see org.klojang.templates.Template
   * @see org.klojang.templates.RenderSession#set(String, Object)
   * @see org.klojang.util.ArrayMethods#implode(Object[])
   * @see org.klojang.util.CollectionMethods#implode(Collection)
   */
  default SQLSession set(String varName, Object value)
        throws UnsupportedOperationException {
<span class="nc" id="L52">    throw notSupported(&quot;set&quot;);</span>
  }

  /**
   * Sets the specified template variable to the escaped and quoted version of the
   * specified value. The value is escaped and quoted using the
   * {@link #quoteValue(Object)} method. Use this method if the source of the value is
   * unknown to prevent SQL injection.
   *
   * @param varName the name of the template variable
   * @param value the value to set the variable to
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   * @see #quoteValue(Object)
   */
  default SQLSession quote(String varName, Object value)
        throws UnsupportedOperationException {
<span class="nc" id="L70">    throw notSupported(&quot;quote&quot;);</span>
  }

  /**
   * &lt;p&gt;Sets the contents of the VALUES clause within an INSERT statement.Equivalent to
   * {@link #setValues(List, BeanValueProcessor) setValues(Arrays.asList(beans),
   * BeanValueProcessor.identity())}.
   *
   * @param &lt;T&gt; the type of the beans or records to persist
   * @param beans the beans or records to persist (at least one required)
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} or
   *       {@link SQL#template(String) SQL.template()} method
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  default &lt;T&gt; SQLSession setValues(T... beans) throws UnsupportedOperationException {
<span class="nc" id="L87">    throw new UnsupportedOperationException(sqlSkeletonsOnly());</span>
  }

  /**
   * &lt;p&gt;Sets the contents of the VALUES clause within an INSERT statement. Equivalent to
   * {@link #setValues(List, BeanValueProcessor) setValues(beans,
   * BeanValueProcessor.identity())}.
   *
   * @param &lt;T&gt; the type of the beans or records to persist
   * @param beans the beans or records to persist (at least one required).
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} or
   *       {@link SQL#template(String) SQL.template()} method
   */
  default &lt;T&gt; SQLSession setValues(List&lt;T&gt; beans) throws UnsupportedOperationException {
<span class="nc" id="L103">    throw new UnsupportedOperationException(sqlSkeletonsOnly());</span>
  }

  /**
   * &lt;p&gt;Sets the contents of the VALUES clause within an INSERT statement. This method
   * is only supported by {@code SQL} instances obtained via
   * {@link SQL#skeleton(String) SQL.skeleton()}. The SQL template must contain a nested
   * template named &quot;record&quot;. This template will be repeated for each of the beans or
   * records in the provided list. This is best illustrated using an example:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * record Person(Integer id, String firstName, String lastName, int age) {}
   *
   * // ...
   *
   * List&lt;Person&gt; persons = List.of(
   *    new Person(null, &quot;John&quot;, &quot;Smith&quot;, 34),
   *    new Person(null, &quot;Francis&quot;, &quot;O'Donell&quot;, 27),
   *    new Person(null, &quot;Mary&quot;, &quot;Bear&quot;, 52));
   *
   * SQL sql = SQL.skeleton(&quot;&quot;&quot;
   *    INSERT INTO PERSON(FIRST_NAME,LAST_NAME,AGE) VALUES
   *    ~%%begin:record%
   *    (~%firstName%,~%lastName%,~%age%)
   *    ~%%end:record%
   *    &quot;&quot;&quot;);
   *
   * BeanValueProcessor processor = (bean, prop, val, quoter) -&gt; {
   *     if(prop.equals(&quot;firstName&quot;) {
   *       return quoter.sqlFunction(&quot;SUBSTRING&quot;, val, 1, 3);
   *     }
   *     return val;
   * };
   *
   * try(Connection con = ...) {
   *   try(SQLSession session = sql.session(con)) {
   *     session.setValues(persons, processor).execute();
   *   }
   *   String query = &quot;SELECT FIRST_NAME FROM PERSON&quot;;
   *   List&lt;String&gt; firstNames = SQL.simpleQuery(con, query).firstColumn();
   *   assertEquals(List.of(&quot;Joh&quot;, &quot;Fra&quot;, &quot;Mar&quot;), firstNames);
   * }
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   *
   * &lt;p&gt;The above code snippet will execute the following SQL:
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * INSERT INTO PERSON(FIRST_NAME,LAST_NAME,AGE) VALUES
   * (SUBSTRING('John', 1, 3), 'Smith', 34),
   * (SUBSTRING('Francis', 1, 3), 'O''Donell', 27),
   * (SUBSTRING('Mary', 1, 3), 'Bear', 52)
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;Beware of mixing multiple types of elements within the {@code List} of beans.
   * Under the hood this method creates a {@link BeanReader} for the class of the first
   * element in the {@code List}. Any subsequent element must have the same class as, or
   * be a subclass of that class.
   *
   * @param &lt;T&gt; the type of the beans or records to persist
   * @param beans the beans or records to persist (at least one required)
   * @param processor a {@code BeanValueProcessor} that allows you to selectively
   *       convert values within the provided beans or records
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} or
   *       {@link SQL#template(String) SQL.template()} method
   * @see SQLInsert#insertBatchAndGetIDs(List)
   * @see SQLInsert#insertBatchAndSetIDs(String, List)
   */
  default &lt;T&gt; SQLSession setValues(List&lt;T&gt; beans, BeanValueProcessor&lt;T&gt; processor)
        throws UnsupportedOperationException {
<span class="nc" id="L174">    throw new UnsupportedOperationException(sqlSkeletonsOnly());</span>
  }

  /**
   * Sets a template variable named &quot;sortColumn&quot; to the specified value. This presumes and
   * requires that the SQL template indeed contains a variable with that name. This is a
   * convenience method facilitating the most common use case for template variables: to
   * parametrize the column(s) in the ORDER BY clause.
   *
   * @param sortColumn the column(s) to sort on
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLSession setOrderBy(Object sortColumn) throws UnsupportedOperationException {
<span class="nc" id="L189">    return set(&quot;sortColumn&quot;, sortColumn);</span>
  }

  /**
   * Sets a template variable named &quot;sortOrder&quot; to the specified value. This presumes and
   * requires that the SQL template indeed contains a variable with that name. The
   * provided value supposedly is either &quot;ASC&quot; or &quot;DESC&quot;. The value may also be a boolean,
   * in which case {@code true} is translated into &quot;DESC&quot; and {@code false} into &quot;ASC&quot;.
   * This is a convenience method facilitating the most common use case for template
   * variables: to parametrize the sort order for the column(s) in the ORDER BY clause.
   *
   * @param sortOrder the sort order
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLSession setSortOrder(Object sortOrder) throws UnsupportedOperationException {
<span class="nc bnc" id="L206" title="All 2 branches missed.">    return (sortOrder instanceof Boolean)</span>
<span class="nc" id="L207">          ? setDescending((Boolean) sortOrder)</span>
<span class="nc" id="L208">          : set(&quot;sortOrder&quot;, sortOrder);</span>
  }

  /**
   * Sets a template variable named &quot;sortOrder&quot; to &quot;DESC&quot; if the argument equals
   * {@code true}, else to &quot;ASC&quot;.
   *
   * @param isDescending whether to sort in descending order
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLSession setDescending(boolean isDescending)
        throws UnsupportedOperationException {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    return set(&quot;sortOrder&quot;, isDescending ? &quot;DESC&quot; : &quot;ASC&quot;);</span>
  }

  /**
   * Sets the sort column and sort order of an ORDER BY clause.
   *
   * @param sortColumn the column to sort on
   * @param sortOrder the sort order
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLSession setOrderBy(Object sortColumn, Object sortOrder)
        throws UnsupportedOperationException {
<span class="nc" id="L236">    return setOrderBy(sortColumn).setSortOrder(sortOrder);</span>
  }

  /**
   * Sets the sort column and sort order of an ORDER BY clause.
   *
   * @param sortColumn the column to sort on
   * @param isDescending whether to sort in descending order
   * @return this {@code SQLSession} instance
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLSession setOrderBy(Object sortColumn, boolean isDescending)
        throws UnsupportedOperationException {
<span class="nc" id="L250">    return setOrderBy(sortColumn).setDescending(isDescending);</span>
  }

  /**
   * &lt;p&gt;Escapes and quotes the specified value. More precisely:
   * &lt;ul&gt;
   *     &lt;li&gt;If the value is {@code null}, the literal string &quot;NULL&quot;
   *         (&lt;i&gt;without&lt;/i&gt; quotes) is returned.
   *     &lt;li&gt;If the value is a {@link Number}, a {@link Boolean}, or a
   *         {@link SQLExpression}, the value is returned as-is. That is,
   *         {@code toString()} will be called on the value, but the resulting string
   *         will &lt;i&gt;not&lt;/i&gt; be quoted.
   *     &lt;li&gt;Otherwise the value is escaped and quoted according to the quoting rules of
   *         the target database.
   * &lt;/ul&gt;
   * &lt;p&gt;Use this method if the value is passed in from outside your program to prevent
   * SQL injection.
   *
   * @param value the value to be escaped and quoted
   * @return the escaped and quoted value
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   * @see java.sql.Statement#enquoteLiteral(String)
   */
  default String quoteValue(Object value) throws UnsupportedOperationException {
<span class="nc" id="L275">    throw notSupported(&quot;quoteValue&quot;);</span>
  }

  /**
   * Generates a SQL function call in which each of the function arguments is escaped and
   * quoted using the {@link #quoteValue(Object) quoteValue()} method.
   *
   * @param name the name of the function
   * @param args the function arguments. Each of the provided arguments will be
   *       escaped and quoted using {@link #quoteValue(Object)}.
   * @return an {@code SQLExpression} representing a SQL function call
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   */
  default SQLExpression sqlFunction(String name, Object... args)
        throws UnsupportedOperationException {
<span class="nc" id="L291">    throw notSupported(&quot;sqlFunction&quot;);</span>
  }

  /**
   * If necessary, quotes the specified identifier (e&amp;#46;g&amp;#46; a column name or table
   * name) according to the quoting rules of the target database. Use this method if the
   * identifier is passed in from outside your program to prevent SQL injection.
   *
   * @param identifier the identifier to quote
   * @return the quoted identifier
   * @throws UnsupportedOperationException in case this {@code SQLSession} was
   *       obtained via the {@link SQL#simple(String) SQL.simple()} method
   * @see java.sql.Statement#enquoteIdentifier(String, boolean)
   */
  default String quoteIdentifier(String identifier) throws UnsupportedOperationException {
<span class="nc" id="L306">    throw notSupported(&quot;quoteIdentifier&quot;);</span>
  }

  /**
   * Executes the SQL. You can call this method either if the SQL is completely static, or
   * if you have set all template variables and the SQL does not contain any named
   * parameters. If the SQL &lt;i&gt;does&lt;/i&gt; contain named parameters, you will first have to
   * bind them. Call {@link #prepareInsert()}, or {@link #prepareUpdate()} to obtain a
   * {@link SQLStatement} that enables you to bind the named parameters. Although you
   * &lt;i&gt;could&lt;/i&gt; call this method for SQL SELECT statements, it does not make much sense
   * because this method does not return any feedback from the database.
   */
  void execute();

  /**
   * Returns a {@code SQLQuery} instance that allows you to provide values for named
   * parameters (&quot;binding&quot;) and then execute the query.
   *
   * @return a {@code SQLQuery} instance
   */
  SQLQuery prepareQuery();

  /**
   * Returns a {@code SQLInsert} instance that allows you to provide values for named
   * parameters (&quot;binding&quot;) and then execute the INSERT statement. Auto-generated keys
   * will be made available to the client.
   *
   * @return a {@code SQLInsert} instance
   */
  default SQLInsert prepareInsert() {
<span class="fc" id="L336">    return prepareInsert(true);</span>
  }

  /**
   * Returns a {@code SQLInsert} instance that allows you to provide values for named
   * parameters (&quot;binding&quot;) and then execute the INSERT statement.
   *
   * @param retrieveAutoKeys whether to retrieve the keys that were generated by the
   *       database
   * @return a {@code SQLInsert} instance
   */
  SQLInsert prepareInsert(boolean retrieveAutoKeys);

  /**
   * Returns a {@code SQLUpdate} instance that allows you to provide values for named
   * parameters (&quot;binding&quot;) and then execute the UPDATE or DELETE statement.
   *
   * @return a {@code SQLUpdate} instance
   */
  SQLUpdate prepareUpdate();

  private static UnsupportedOperationException notSupported(String method) {
<span class="nc" id="L358">    String fmt = &quot;method %s() only supported for SQL templates and SQL skeletons&quot;;</span>
<span class="nc" id="L359">    return new UnsupportedOperationException(String.format(fmt, method));</span>
  }

  private static String sqlSkeletonsOnly() {
<span class="nc" id="L363">    return &quot;setValues() only supported for SQL skeletons&quot;;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>